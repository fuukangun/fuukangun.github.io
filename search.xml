<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Solr学习:managed-schema详解]]></title>
      <url>%2F2017%2F03%2F09%2FSolr%E5%AD%A6%E4%B9%A0-managed-schema%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[前言 本文很大程度借鉴抄袭转载自：一剑侵心的博客:关于Solr学习的那部分 在公司自己搭建Solr玩的时候，因为用的JDK是1.7版本的，所以安装了Solr5.3.1(大概是这个版本吧，记不清了，也可能是4.x的)。当时的配置文件叫schema.xml，搞得我一开始没找到配置文件，还以为在官网下了一个假Solr。结果Solr不知道从5.x版本开始，虽然配置文件还是xml格式，但是改名叫managed-schema，还是不带后缀的那种，简直了。 其实managed-schema的格式简单来看就是下面这个样子的： 12345678&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;schema name="example" version="1.6"&gt; &lt;field/&gt; &lt;dynamicField/&gt; &lt;uniqueKey&gt;id&lt;/uniqueKey&gt; &lt;copyField/&gt; &lt;fieldType/&gt;&lt;/schema&gt; field元素 特殊之处field用来配置document中的字段，类似于数据库中的column。但是这里有三个特殊一点的字段，分别是：_version_, _root_ 和 id。 _version_如果去除此字段，必须同时去掉solrconfig.xml中的update log。_version_ and update log 在SolrCloud中是必须的。作用类似于hibernate中的version字段，用于乐观锁。 _root_如果document中内嵌document，此需要此字段。用于内嵌的document指向其父document。 id除非你有很充足的理由，否则不要去除”id”字段。不要改变type属性， 不要对对应的字段进行索引时分析。 field元素的属性 属性名称 默认值 属性说明 name 必填 type 必填，值必须定义在中 indexed true 是否进行索引。 true的时候进行索引。 stored true 是否存储。如果此字段的值需要显示在搜索结果中，则需要进行存储。 docValues fasle 是否需要存储docValues。true为设置。docValues用于提升sorting, faceting, grouping, function queries等性能，现在仅支持StrField, UUIDFiel和所有的Trie*Field，此值为true的字段要求此字段 multiValued=false，并且 (required=true或设置了default的值)。 multiValued fasle 是否有多个值。 omitNorms 如果你的大部分的document的长度大小都差不多，则设置成true。如果此字段在索引时需要boost，则设置为false。 termVectors fasle 设置为true，使More Like This特性生效，会极大的增加索引文件的大小。 termPositions fasle 通常用于提高高亮搜索结果这一功能的性能。设置为true，会增加索引文件的大小。 termOffsets fasle 通常用于提高高亮搜索结果这一功能的性能。设置为true，会增加索引文件的大小。 termPayloads fasle 通常用于提高高亮搜索结果这一功能的性能。设置为true，会增加索引文件的大小。 required fasle 是否为必填值。 如果设置为true，则索引时，如果此字段值为null，则会报错。如果是字符串，亲测使用””也会报错。 default 这个field的默认值。 dynamicField元素 动态字段 属性配置上与常规字段没啥区别，最大的区别是name的属性上可以进行通配，比如说name=”*_i”，那么只要是后面带i的字段都是符合的。这样就不怕一些字段无法匹配无法写入。 uniqueKey元素 类似于数据库中的主键。配置文件默认的是id。我们在数据库设计时，虽然不强制每个表有主键，但是一般情况下还是会设置一个主键的。同样这个元素也不是必须的，但是强烈建议设置此值。 copyField 假设有这样一个需求：根据书名或者作者名查询图书馆的图书。如果在数据库中，我们可以写成select * from book where author like `%东野圭吾%` or book_name like `%东野圭吾%`。但是在Solr中没有这样的语法。所以，我们需要把author字段和book_name字段拷贝到一个新字段中，通过这个字段来实现上面的需求。写法如下： 123&lt;field name="text" type="string" index="true" stored="true" multiValues="true" /&gt;&lt;copyField source="author" dest="text" /&gt;&lt;copyField source="book_name" dest="text" /&gt; 这样我们就只需要搜索text里的内容就可以了。 注意：如果dest由多个source构成，就需要将其指定为multiValued。 fieldType fieldType主要定义了一些字段类型，其name属性值用于前面中的type属性的值。e.g. 其中class属性中”solr”是org.apache.solr.schema这个包名的缩写。 fieldType的属性： name 由字母、数字和下划线组成。不能以数字开头。此值用于前面中的type属性的值。 class 此值表明索引并存储此fieldType的数据的类型（e.g 字符类型，数字类型，日期类型…）。如果此类不是solr提供的（自定义的或第三方的类），则不能用”solr.”，需要写类的全路径名。 positionIncrementGap 值为整数，用于multiValued=”true”的字段，指定多个值之间的距离，以防出现假的短语匹配。 比如描述书本作者的字段是有多个值的，假设有两个作者：John Smith 和 Mike Jackson，我们搜索”Smith Mike”这个作者，如果positionIncrementGap值设成0，则此记录就会被认为是匹配搜索条件的，实际上是不匹配的。对于这种情况，我们应该把此值设置成一个较大的值，比如100。 autoGeneratePhaseQueries 值为布尔类型。默认值为false。设为true时，会自动生成短语查询。 举个粟子：索引中的文本内容为：春花秋月何时了…一江春水向东流。 我们在搜索的输入框里输入”春花”（注意不输入两个双引号），如果autoGeneratePhaseQueries 为true，我们加上highlight的话，返回的匹配结果为： 春花春花秋月何时了…一江春水向东流。 如果值为false，则返回结果为春花春花秋月何时了…一江春水向东流。 如果值为false，我们还是想要进行短语查询，可在输入框里输入”春花”(注意需要加上两个双引号)。 docValuesFormat 自定义docValues的格式。设置此值的话，必须在solrconfig.xml里配置schema-aware codec。如： 1&lt;codecFactory class="solr.SchemaCodecFactory" /&gt; 在网上搜了一下，只看到有两个值 Memory 和 Disk。猜想这个属性的作用应该是定义docValues值是存在硬盘上还是存在内存中吧。 postingsFormat 自定义PostingsFormat。设置此值的话，必须在solrconfig.xml里配置schema-aware codec。不太清楚具体有什么用。 注：尽量不要使用docValuesFormat和postingFormat。Solr的guideline上有一段话，翻译如下： 仅当使用默认的codec 时，Lucene索引才支持向后兼容。因此，如果使用了这两个属性，那么将来想要升级到更高版本的Solr 时，需要你切换回默认的codec，然后优化现有的索引或者重新建立整个索引。 以下的属性也同时存在于里，如果里的值会覆盖里的值。 indexed 布尔值。true表示进行索引。 stored 布尔值。true表示进行存储。 docValues 布尔值。true表示field的值将会被存储于面向列的数据结构中。 sortMissingFirst 布尔值。true表示排序的时候，此field值为空的记录排在此field值不为空的记录的前面。 sortMissingLast 布尔值 。意思和sortMissingFirst相反。 multiValues 布尔值。 omitNorms 布尔值。 omitTermFreqAndPositions 布尔值。忽略term frequency, positions 和 payloads。所有非文本类型字段，此默认值是true。 omitPositions 布尔值。布尔值。忽略positions。 termVectors， termPositions， termOffsets 和 termPayloads 布尔值。 required 布尔值。 useDocValuesAsStored 布尔值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Solr学习:为Solr添加数据]]></title>
      <url>%2F2017%2F03%2F04%2FSolr%E5%AD%A6%E4%B9%A0-%E4%B8%BASolr%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%2F</url>
      <content type="text"><![CDATA[schema配置简介 为什么此处只做一个简介，而不是放一篇详解上来？因为本文主要讲解如何为Solr添加数据，对于schema配置的详解，不是重点。想要了解清楚的各位，可以自行查询，网上很多关于schema的详解。或者也可以直接参看相关的官方wiki：链接直达 把Solr的一个Core当作数据库的一张表，那么其schema就相当于这个表的表结构设计。（本人刚刚接触Solr，如果表述有误，欢迎指正）也就是说，在添加数据之前，我们得先设计好表结构。 那么，schema的配置文件在哪呢？其实就在solr_home/solr/fuukangun（此处是你的Core name）/conf下找到managed-schema（之前的版本是schema.xml文件）。 打开managed-schema文件，我们可以看到里面默认配置了很多filed，也就是说默认了很多字段。你可以将里面的filed全删除，配上你想要的字段。但是值得注意的是，类似_version_和_root_这种带下划线的字段，是系统保留字段，可以不删除，但建议你的数据库中，表字段不要类似命名。 由于已经有默认配置了，那么我在这里就直接用原本自带的部分字段好了。这里选用id，sku，name三个字段，将其他的field注释或删除。看这几个field名称，应该是用来存储商品信息的。 123&lt;field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false" /&gt;&lt;field name="sku" type="string" indexed="true" stored="true" omitNorms="true"/&gt;&lt;field name="name" type="string" indexed="true" stored="true"/&gt; 在Solr控制台添加数据 在Solr控制台选择核心以后，点击下方的Documents按钮。Solr上一条数据可以看成是一个Document。 Document Type可以选择很多，我在这里选择了JSON。然后在下面填入JSON格式的数据，点击Submit Document。右下角显示Status: success就表示数据添加成功了。我们也可以在这里添加一个数组的对象，不一定要一个个添加。 进行数据查询 选择左边菜单栏里面的Query，点击最下面的Execute Query按钮就会在右边出现查询结果了。上面的q输入框内，就是输入查询条件的，*:*就是检索所有条件的。比如我们这个索引只有三个字段：id，sku，name。我们根据name模糊查询的话，可以写成name:雀巢*。*的作用，类似于MySQL中的%。当然，我们也可以精确查询。另外一些设置这里不在简述。 1. 问题出现 但是，在点击了Execute Query按钮之后，界面上并没有出现任何数据。于是通过调试，我在控制台发现了服务器400的错误。个人怀疑是Tomcat上解析URL出错了，我把URL复制下来，粘贴到浏览器的地址栏，把%2F修改为/。结果成功获得了刚刚添加过的数据。 2. 解决方式 找到Tomcat/conf目录下的catalina.properties文件，在最下面添加如下代码：org.apache.tomcat.util.buf.UDecoder.ALLOW_ENCODED_SLASH=true重启Tomcat，就能使Tomcat正确解析出URL了。 3. 结果查看 然后我们再进一次Solr控制台，就能看到搜索结果了。 从MySQL导入数据到Solr 解决了上面的问题，我们继续来尝试一下如何从数据库导入数据到Solr。 首先在数据库建立相同格式的表，并在表里加几条数据。 要想Solr连接数据库，需要两个jar包： mysql-connector-java-5.1.41-bin.jar（这个不需要多说，没有的可以自行下载） solr-5.5.0/dist目录下，solr-dataimporthandler-5.5.0.jar 将这两个包，拷贝到Tomcat\webapps\solr\WEB-INF\lib目录下。 配置solr_home/solr/yourCore/conf目录下的solrconf.xml文件。在前面上加上一个dataimport的处理的Handler 12345&lt;requestHandler name="/dataimport" class="org.apache.solr.handler.dataimport.DataImportHandler"&gt; &lt;lst name="defaults"&gt; &lt;str name="config"&gt;data-config.xml&lt;/str&gt; &lt;/lst&gt;&lt;/requestHandler&gt; 在同目录下，创建data-config.xml文件 dataSource是数据库数据源。 Entity就是一张表对应的实体，pk是主键，query是查询语句。 Field对应一个字段，column是数据库里的column名，后面的name属性对应着Solr的Filed的名字。 123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;dataConfig&gt; &lt;dataSource type="JdbcDataSource" driver="com.mysql.jdbc.Driver" url="jdbc:mysql://127.0.0.1:3306/solr_data" user="root" password="root" batchSize="-1" /&gt; &lt;document name="goods"&gt; &lt;entity name="goods" pk="id" query="select * from goods"&gt; &lt;field column="id" name="id"/&gt; &lt;field column="sku" name="sku"/&gt; &lt;field column="name" name="name"/&gt; &lt;/entity&gt; &lt;/document&gt;&lt;/dataConfig&gt; 重启Tomcat，在Solr控制台，选择Dataimport，点击Execute从MySQL导入数据。可能需要稍微等几秒，点击Refresh Status刷新倒入状态，出现下图，表示数据导入成功。 点击Query查询数据 但是原本我们通过控制台添加的数据消失了，这是因为我们在上一步点击Execute导入数据时，勾选了clean的缘故。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Solr学习:Core配置]]></title>
      <url>%2F2017%2F02%2F25%2FSolr%E5%AD%A6%E4%B9%A0-Core%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[前言 上回说到，如何搭建Solr5.5.0，进入Solr控制台。但是，可以看到，此时控制台左边Core选择栏，显示的是No cores available。也就是说，Solr从5.X开始就不提供默认的Core了，而需要我们自行配置。本文就讲述如何配置第一个Core。 配置年轻人的第一个Core 首先，进入你原来配置的solr_home/solr目录下，创建一个文件夹，命名成你的CoreName。比如我创建了fuukangunCore。 接着，将solr_home/configsets/sample_techproducts_configs下的conf文件夹拷贝到solr_home/solr/fuukangunCore文件夹里。 然后，启动Tomcat，进入Solr控制台，点击左边的No cores available，然后Add Core。在name和instanceDir中填入你的CoreName。比如笔者就要填入fuukangunCore。注：Solr Core的命名有一定规范，具体可自行百度 最后，原本的No cores available就变成了Core Selector，在此可以选择你的Core。你也可以创建更多的Core。现在，你的Core目录下，应该多了core.properties文件和data文件夹。data文件夹式用于存储索引文件的，而core.properties文件则存放了Core的一些配置信息。 但是虽然我们有了Core，依旧缺少核心的东西，就是数据。下一次，我将会介绍如何配置Core的schema和从MySQL导入数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Solr学习:Solr5.5.0搭建]]></title>
      <url>%2F2017%2F02%2F24%2FSolr%E5%AD%A6%E4%B9%A0-Solr5-5-0%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[前言 最近在工作上，由于DB使用了Cobar进行分库，所以表关联无法得以实现，需要在Solr上来进行一些复杂的查询。而且即便不进行分库，DB操作也不建议大数据量的多表进行关联查询，尤其是那种4、5张大表进行join的操作。然后顺带学习和了解一下Solr。 需要注意的是Solr6以上版本需要JDK8，Solr5以上版本需要JDK7。 Solr搭建 下载Solr 5.5.0，并解压到当前目录下。 下载Tomcat，此处我用的是Tomcat8.5.11。 将solr-5.5.0/server/solr-webapp下的webapp文件夹拷贝到Tomcat/webapps下，并将拷贝过来的webapp重命名成solr。（此处建议先把Tomcat/webapps下内容全部清空） 把solr-5.5.0/server/lib/ext中的jar包复制到Tomcat/webapps/solr/WEB-INF/lib目录中。 在任意位置新建solr_home文件夹，我建立在/Users/fuukangun路径下。把solr-5.5.0/server下的solr文件夹，拷贝到刚刚创建的solr_home文件夹下。solr_home就是之后创建索引实例Core的需要的目录 把solr-5.5.0/server/resources下的log4j.properties文件拷贝到Tomcat/webapps/solr/WEB-INF/classes目录下（classes不存在需要手动创建） 打开Tomcat/webapps/solr/WEB-INF下的web.xml文件。找到下面的配置内容，配置solr_home，一开始应该是被注释掉了。 12345&lt;env-entry&gt; &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt; &lt;env-entry-value&gt;/put/your/solr/home/here&lt;/env-entry-value&gt; &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt; &lt;/env-entry&gt; 将env-entry-value值替换为/Users/fuukangun/solr_home/solr，保存。 启动Tomcat，在浏览器输入http://localhost:8080/solr/index.html#/ 就能出现Solr控制台了。]]></content>
    </entry>

    
  
  
</search>
